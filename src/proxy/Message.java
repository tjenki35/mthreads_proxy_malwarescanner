package proxy;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Super class for http request/reponse
 *
 * @author Torie
 */
public abstract class Message {

    /**
     * According to to the java API documentation for Pattern.class states that
     * these instances are immutable However, the matcher classes are not.
     */
    protected static final Pattern REGEX_HEADER = Pattern.compile("(.+?)(?: |):(?:| )((?:\\s|.){1,})");
    protected static final String HOST_STRING = "(?:(?:(http(?:s|)|ftp|https):\\/\\/)|){0,1}(?:(?:((?:.+?[.]){2,8}?[^\\/:]+))(?:(?:[:](\\d{1,8}))|))(?:(\\/.*[.]*.)|)|((?:~{0,1}\\/.*[.]*.))";
    protected static final Pattern REGEX_HOST = Pattern.compile(HOST_STRING);
    protected static final Pattern REGEX_RESPONSE = Pattern.compile("(HTTP/1[.](?:1|0)) ([1-5][0-9]{2}) (.*)");
    protected static final Pattern REGEX_REQUEST = Pattern.compile("([A-Z]{1,8}) ((?:.*[.].*[.].*)|(?:" + HOST_STRING + ")) (HTTP/1[.](?:1|0))");

    public String host;
    public String path;
    public String contentType;
    public String protocol;
    public String encoding; //typical headers values that are parsable
    public int contentLength = -1;
    public int port = -1;
    public boolean chunked;
    public byte[] buffer;
    public StringBuilder body;
    public ArrayList<String> headers;

    protected boolean transmitComplete = false;
    private int line = 0;

    public Message() {
        headers = new ArrayList<>();
    }

    protected String pack() throws ParseException {
        StringBuilder build = new StringBuilder();
        for (String header : headers) {
            build.append(header);
            build.append("\r\n");
        }
        build.append("\r\n");
        if (body != null) {
            build.append(body.toString());
        }
        return build.toString();
    }

    public boolean done() {
        return transmitComplete;
    }

    public void nextLine(String str) throws ParseException, NotImplementedException { //refactor:: str->line
        if (transmitComplete) {
            return;
        }
        switch (line) {
            case 0:
                if (str.isEmpty()) {
                    return;
                }
                parseArguments(str);
                line++;
                break;
            case 1:
                if (str.isEmpty()) {
                    if (headers.isEmpty()) {
                        transmitComplete = true;
                    }
                    transmitComplete = true;
                    return;
                }
                parseHeader(str);
                break;
            default:
                break;
        }
    }

    protected abstract void parseArguments(String line) throws ParseException, NotImplementedException;

    //parse all common headers here. ( todo )
    protected Matcher parseHeader(String line) throws ParseException {
        Matcher match = REGEX_HEADER.matcher(line);
        if (!match.find()) {
            throw new ParseException("Malformed Header: " + line);
        }
        String type = match.group(1).trim().toLowerCase();
        String value = match.group(2).replaceAll(" ", "").toLowerCase();
        if (type.equals("content-length")) {
            contentLength = Integer.parseInt(value);
        } else if (type.equals("content-encoding")) {
            encoding = match.group(2);
        }
        return match;
    }

}
