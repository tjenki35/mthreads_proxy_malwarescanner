package proxy;

import java.util.HashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.io.File;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.io.FileOutputStream;


/**
 * //todo: rename class to instance manager.
 * //separate instance management for individual variables
 * //add instance status update (active ports, etc) -- easy stuff for now.
 *
 * @author Torie Jenkins
 */
public class Proxy {

    private final ThreadPoolExecutor activeServices;
    private final HashMap<Integer, Instance> portTable = new HashMap<>();
    public final AtomicBoolean verbose = new AtomicBoolean(false);
    public final AtomicBoolean xverbose = new AtomicBoolean(false);
    public final AtomicBoolean scanCymru = new AtomicBoolean(true);
    private final AtomicBoolean alive = new AtomicBoolean(false);

    Proxy() {
        activeServices = (ThreadPoolExecutor) Executors.newCachedThreadPool();
        alive.set(true);
    }

    /**
     * Start an instance on the specified port
     *
     * @param port
     */
    public void startOnPort(final int port, String file_path) { //start the server in a new thread
        if (!alive.get()) {
            alive.set(true);
        }
        if (!portTable.containsKey(port)) {
            Instance instance;
            try {
                instance = new Instance();
            } catch (Exception ex) {
                System.err.println("startOnPort: debug: " + ex.getMessage());
                return;
            }

            try{
                if(file_path!=null){
                    File logs = new File(file_path);
                    if(!logs.canWrite()){
                        logs.createNewFile();
                        instance.setOutputStream(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(logs))), true);
                    }else{
                        System.err.println("Cannot write to file, defaulting to stdout");
                    }
                }
            }catch(NullPointerException | IOException | SecurityException ex){
                System.err.println("Error accessing given file: reason: "+ex.getMessage());
            }

            //start instance without scanning, with a verbosity level of 1.
            instance.setParameters(port, false, 1);
            portTable.put(port, instance);
            System.out.println("Starting Service on Port "+port+"...");
            activeServices.submit(instance);
        } else {
            System.out.println("Port already being monitored!");
        }
    }

    /**
     * Returns an instance for a specific port, returns null if the port is not active
     */
    public Instance getInstance(int port){
        if(portTable.containsKey(port)){
            return portTable.get(port);
        }
        return null;
    }


    /**
     * Update all running instances
     */
    public void updateSettings() {
        portTable.forEach((i, instance) -> {
            instance.setVerbosity(((verbose.get()) ? 1 : 0) + ((xverbose.get()) ? 1 : 0));
            instance.runMalwareScanning(scanCymru.get());
        });
    }


    public void getPortStatus(){
        StringBuilder build = new StringBuilder();
        portTable.forEach((i, instance) -> {
                build.append(instance.getStatus()+'\n');
            });
        System.out.println(build.toString());
    }



    /**
     * Stop instance listening on the specified port
     *
     * @param port
     */
    public void stop(int port) {
        if (alive.get()) {
            if (portTable.containsKey(port)) {
                portTable.get(port).interrupt();
                portTable.remove(port);
                System.out.println("Stopped Service on Port: " + port+"..."); //need to add underlying error checking for use of the sockets
            }else{
                System.out.println("No Service Running on Port: "+port);
            }
        }
    }

    /**
     * Attempts to shutdown all instances listening on all ports
     */
    public void shutdown() {
        portTable.values().forEach((thread) -> thread.interrupt());
    }

    /**
     * Returns the status of the proxy server
     *
     * @return
     */
    public boolean running() {
        return alive.get();
    }

}
