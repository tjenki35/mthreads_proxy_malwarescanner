package proxy.networking;

import proxy.exceptions.NotImplementedException;
import proxy.exceptions.ParseException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Super class for http request/reponse
 *
 * @author Torie Jenkins u1038290
 */
public abstract class Message {

    /**
     * According to to the java API documentation for Pattern.class states that
     * these instances are immutable However, the matcher classes are not.
     * todo: make the parsing a bit more generic here.
     */
    protected static final Pattern REGEX_HEADER = Pattern.compile("(.+): (.+)");
    private static final char c = '/';
    protected static final String HOST_STRING = "^(?:(https?)://)??(?:((?:\\w|[.-])+))?(?::(\\d{1,8}))??/?((?:/.+)+?)?$";
    protected static final Pattern REGEX_HOST = Pattern.compile(HOST_STRING);
    protected static final Pattern REGEX_RESPONSE = Pattern.compile("(HTTP/1[.](?:1|0)) ([1-5][0-9]{2}) (.*)");
    protected static final Pattern REGEX_REQUEST = Pattern.compile("([A-Z]{1,8})\\s([^\\s]*)\\s(HTTP/1[.](?:1|0))");

    public String host;
    public String path;
    public String contentType;
    public String protocol;
    public String encoding; //typical headers values that are parsable
    public int contentLength = -1;
    public int port = -1;
    public boolean chunked;
    public byte[] buffer;
    public ArrayList<String> headers;

    protected boolean transmitComplete = false;
    private int line = 0;

    public Message() {
        headers = new ArrayList<>();
    }

    /**
     * Returns a String representation of this object
     *
     * @return
     * @throws ParseException
     */
    protected String pack() throws ParseException {
        StringBuilder build = new StringBuilder();
        headers.forEach((header) -> {
            build.append(header);
            build.append("\r\n");
        });
        if (contentType != null || !"".equals(contentType)) {
            headers.add("Content-Type: " + contentType);
        }
        build.append("\r\n");
        return build.toString();
    }

    /**
     * Indicates whether or not a full message has been recieved (HTTP only)
     *
     * @return
     */
    public boolean done() {
        return transmitComplete;
    }

    int tries;

    /**
     * Attempts to parse the next line of input in to the compilation of the
     * message
     *
     * @param str
     * @throws ParseException
     * @throws NotImplementedException
     */
    public void nextLine(String str) throws ParseException, NotImplementedException { //refactor:: str->line
        if (transmitComplete) {
            return;
        }
        if (tries > 2) {
            transmitComplete = true;
        }
        switch (line) {
            case 0:
                if (str.isEmpty()) {
                    tries++;
                    return;
                }
                parseArguments(str);
                line++;
                break;
            case 1:
                if (str.isEmpty()) {
                    if (headers.isEmpty()) {
                        transmitComplete = true;
                    }
                    transmitComplete = true;
                    return;
                }
                parseHeader(str);
                break;
            default:
                break;
        }
    }

    protected abstract void parseArguments(String line) throws ParseException, NotImplementedException;

    /**
     * Parses and filters headers accordingly to configuration
     *
     * @param line
     * @return
     * @throws ParseException
     */
    protected Matcher parseHeader(String line) throws ParseException {
        Matcher match = REGEX_HEADER.matcher(line);
        if (!match.find()) {
            throw new ParseException("Malformed Header:" + line, 400, "Bad Request", Sources.BAD_REQUEST);
        }
        String type = match.group(1).toLowerCase();
        String value = match.group(2).toLowerCase();
        switch (type) {
            case "content-type":
                contentType = value;
                return match;
            case "content-encoding":
                encoding = value;
                break;
            case "content-length":
                contentLength = Integer.parseInt(value.trim());
                break;
            case "host":
                parseURI(value);
                break;
            case "proxy-connection":
                line = "Proxy-Connection: close";
                break;
            case "accept-encoding":
                break;
            case "accept":
                line = "Accept: text/html";
                break;
            case "connection":
                line = "Connection: close";
                break;
            default:
                break;
        }
        headers.add(line);
        return match;
    }

    protected void parseURI(String toParse) throws ParseException {
        Matcher match_host = REGEX_HOST.matcher(toParse);
        if (match_host.find()) {
            if (match_host.group(1) != null) {
                protocol = match_host.group(1);
            }
            if (match_host.group(2) != null) {
                host = match_host.group(2);
            }
            if (match_host.group(3) != null) {
                port = Integer.parseInt(match_host.group(3));
            }
            if (match_host.group(4) != null) {
                path = match_host.group(4).replaceAll(" ", "");
            }
            if (host != null && path == null) {
                path = "/";
            }

        } else {
            throw new ParseException("Malformed Host: " + toParse, 400, "Bad Request", Sources.BAD_REQUEST);
        }
    }
}
