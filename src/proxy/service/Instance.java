package proxy.service;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;

/**
 * Represents a single instance of the proxy listening on the port
 *
 * @author tjenkins
 */
public class Instance extends Thread {

    //todo: let variable changes affect separate proxy instances, (add flag to affect all instances)
    //
    //set all categories to false
    private final AtomicBoolean teamcymru = new AtomicBoolean(false);
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final AtomicBoolean verbose = new AtomicBoolean(false);
    private final AtomicBoolean xverbose = new AtomicBoolean(false);

    private BufferedWriter out;
    private final AtomicInteger port = new AtomicInteger(2020);

    //primary class resources
    private final ServerSocket listener;
    private final ThreadPoolExecutor activeConnections;

    private boolean closeOnExit;

    /**
     * Creates a standard Instance object **note: Java semantics force this
     * signature. This brings the error handling for creation outside of the
     * class.
     *
     * @throws IOException
     */
    public Instance() throws IOException {
        System.out.println("Creating socket on network interface...");
        listener = new ServerSocket();
        System.out.println("Creating threading resources...");
        activeConnections = (ThreadPoolExecutor) Executors.newCachedThreadPool();

        //set our output stream to stdout
        out = new BufferedWriter(new OutputStreamWriter(System.out));

        // TODO: fix stall when trying to close output stream
        closeOnExit = false;
    }

    private void println(String line) {
        try {
            out.write(line);
            out.write('\n');
            out.flush();
        } catch (IOException ex) {
            System.err.println("Error printing to log file: reason: " + ex.getMessage());
        }
    }

    /**
     * Starts a service through this instance object
     */
    @Override
    public void run() {
        try {
            SocketAddress addr = new InetSocketAddress("0.0.0.0", port.get());
            listener.bind(addr);
            listener.setSoTimeout(10000);
            //if bound, continue.
            this.running.set(true);
        } catch (IOException ex) {
            System.out.println("err: socket: port: " + port.get() + ": reason: " + ex.getMessage());
            this.running.set(false);
        }

        while (this.running.get()) { // some try/finally madness
            try {
                Socket client;
                client = listener.accept();
                //configure process and begin processing the client request
                activeConnections.execute(new Process(client, out, verbose.get(), xverbose.get(), teamcymru.get()));
            } catch (InterruptedIOException ex) {
                Thread.currentThread().interrupt();
                // TODO: do something better? (logging)
                // System.out.println("Network Event: " + ex.getMessage());
            } catch (IOException ex) {
                // TODO: do something better? (logging)
                // System.out.println("Network Event: " + ex.getMessage());
            }
        }
    }

    /**
     * Interrupt the current service and shutdown all active connections
     */
    @Override
    public void interrupt() {
        println("@Halting Instance @" + this.toString());
        running.set(false);
        activeConnections.shutdownNow();
        try {
            listener.close();
            if (closeOnExit) {
                out.close();
            }
        } catch (IOException ex) {
            System.err.println("err: exit: resorting to thread interrupt: reason: " + ex.getMessage());
            super.interrupt();
        }
    }

    /**
     * Parameter related functions: experimental with synchronized keyword
     */
    /**
     * Sets the parameters for the port ( config items )
     *
     * @param port
     * @param teamcymru
     * @param verbosity
     */
    public synchronized void setParameters(int port, boolean teamcymru, int verbosity) {
        this.port.set(port);
        this.teamcymru.set(teamcymru);
        setVerbosity(verbosity);
    }

    /**
     * Toggle Malware scanning
     *
     * @param b boolean toggle
     */
    public synchronized void runMalwareScanning(boolean b) {
        teamcymru.set(b);
    }

    /**
     * Set output stream, will close stream after interrupt if specified
     *
     * @param writer
     * @param closeStream
     */
    public synchronized void setOutputStream(BufferedWriter writer, boolean closeStream) {
        out = writer;
        closeOnExit = closeStream;
    }

    /**
     * Get textual status on
     *
     * @return
     */
    public synchronized String getStatus() {
        return "Port: " + port.get() + ", Instance:" + this.toString();
    }

    /**
     * Set's up the port to listen to
     *
     * @param p
     */
    public synchronized void setPort(int p) {
        port.set(p);
    }

    /**
     * Determine if this Instance is running or not
     *
     * @return
     */
    public synchronized boolean isRunning() {
        return this.running.get();
    }

    /**
     * Set verbosity level of instance
     *
     * @param v
     */
    public synchronized void setVerbosity(int v) {
        switch (v) {
            case 0:
                verbose.set(false);
                xverbose.set(false);
                break;
            case 1:
                verbose.set(true);
                xverbose.set(false);
                break;
            case 2:
                verbose.set(true);
                xverbose.set(true);
                break;
            default:
                break;
        }
    }
}
