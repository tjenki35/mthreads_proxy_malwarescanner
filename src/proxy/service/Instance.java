package proxy.service;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.io.BufferedWriter;
import java.io.Writer;
import java.io.OutputStreamWriter;

/**
 * Represents a single instance of the proxy listening on the port
 *
 * @author Torie Jenkins
 */
public class Instance extends Thread {

    //todo: let variable changes affect separate proxy instances, (add flag to affect all instances)
    //

    //set all categories to false
    private final AtomicBoolean teamcymru = new AtomicBoolean(false);
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final AtomicBoolean verbose = new AtomicBoolean(false);
    private final AtomicBoolean xverbose = new AtomicBoolean(false);

    private BufferedWriter out;
    private final AtomicInteger port = new AtomicInteger(2020);

    //primary class resources
    private final ServerSocket listener;
    private final ThreadPoolExecutor activeConnections;

    private boolean closeOnExit;

    /**
     * Creates a standard Instance object **note: Java semantics force this
     * signature. This brings the error handling for creation outside of the
     * class.
     *
     * @throws IOException
     */
    public Instance() throws IOException {
        System.out.println("Creating socket on network interface...");
        listener = new ServerSocket();
        System.out.println("Creating threading resources...");
        activeConnections = (ThreadPoolExecutor) Executors.newCachedThreadPool();

        //set our output stream to stdout
        out = new BufferedWriter(new OutputStreamWriter(System.out));
        closeOnExit = false;
    }

    private void println(String line){
        try{
            out.write(line);
            out.write('\n');
            out.flush();
        }catch(IOException ex){
            System.err.println("Error printing to log file: reason: "+ex.getMessage());
        }
    }

    /**
     * Starts a service through this instance object
     */
    @Override
    public void run() {
        println("Binding to port : " + port.get() + ".....");
        try {
            SocketAddress addr = new InetSocketAddress("0.0.0.0", port.get());
            listener.bind(addr);
            listener.setSoTimeout(10000);
            //if bound, continue.
            running.set(true);
        } catch (IOException ex) {
            println("err: socket: port: " + port.get() + ": reason: " + ex.getMessage());
        }

        println("Waiting for clients :).....");
        while (running.get()) { // some try/finally madness
            try {
                Socket client;
                try {
                    client = listener.accept();
                    //configure process and begin processing the client request
                    activeConnections.execute(new Process(client, out, verbose.get(), xverbose.get(), teamcymru.get()));
                } catch (InterruptedIOException ex) {
                    if (!running.get()) {
                        try{
                            listener.close();
                            out.flush();
                            out.close();
                        }catch(IOException exx){
                            System.err.println("err: cannot tearing down resources: reason: "+ exx.getMessage());
                        }
                        return;
                    } else {
                        continue;
                    }
                }
            } catch (IOException ex) {
                //ignore client errors, (plug and chug)
            }
        }
    }

    /**
     * Interrupt the current service and shutdown all active connections
     */
    @Override
    public void interrupt() {
        println("@Halting Instance @" + this.toString());
        running.set(false);
        activeConnections.shutdownNow();
        try{
            listener.close();
            if(closeOnExit){
                out.close();
            }
        }catch(IOException ex){
            System.err.println("err: exit: resorting to thread interrupt: reason: "+ex.getMessage());
        }
        super.interrupt();
    }

    /**
     * Parameter related functions: experimental with synchronized keyword
     */
    /**
     * Sets the parameters for the port ( config items )
     *
     * @param port
     * @param teamcymru
     * @param verbosity
     */
    public synchronized void setParameters(int port, boolean teamcymru, int verbosity) {
        this.port.set(port);
        this.teamcymru.set(teamcymru);
        setVerbosity(verbosity);
    }


    /**
     * Toggle Malware scanning
     *
     * @param b boolean toggle
     */
    public synchronized void runMalwareScanning(boolean b) {
        teamcymru.set(b);
    }

    /**
     * Set output stream, will close stream after interrupt if specified
     */
    public synchronized void setOutputStream(BufferedWriter writer, boolean closeStream){
        out = writer;
        closeOnExit = closeStream;
    }

    /**
     * Get textual status on
     */
    public synchronized String getStatus(){
        return "Port: "+port.get()+", Instance:"+this.toString();
    }

    /**
     * set's up the port to listen to
     *
     * @param p
     */
    public synchronized void setPort(int p) {
        port.set(p);
    }

    /**
     * Set verbosity level of instance
     *
     * @param v
     */
    public synchronized void setVerbosity(int v) {
        switch (v) {
            case 0:
                verbose.set(false);
                xverbose.set(false);
                break;
            case 1:
                verbose.set(true);
                xverbose.set(false);
                break;
            case 2:
                verbose.set(true);
                xverbose.set(true);
                break;
            default:
                break;
        }
    }
}
