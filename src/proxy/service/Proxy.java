package proxy.service;

import java.util.HashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.io.File;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.io.FileOutputStream;

/**
 * //TODO: rename class to instance manager. //separate instance management for
 * individual variables //add instance status update (active ports, etc) -- easy
 * stuff for now.
 *
 * @author tjenkins
 */
public class Proxy {

    private final ThreadPoolExecutor activeServices;
    private final HashMap<Integer, Instance> portTable = new HashMap<>();
    public final AtomicBoolean verbose = new AtomicBoolean(false);
    public final AtomicBoolean xverbose = new AtomicBoolean(false);
    public final AtomicBoolean scanCymru = new AtomicBoolean(true);
    private final AtomicBoolean alive = new AtomicBoolean(false);

    Proxy() {
        activeServices = (ThreadPoolExecutor) Executors.newCachedThreadPool();
        alive.set(true);
    }

    /**
     * Start an instance on the specified port
     *
     * @param port
     * @param file_path
     */
    public void startOnPort(final int port, String file_path) { //start the server in a new thread
        if (!alive.get()) {
            alive.set(true);
        }
        if (!portTable.containsKey(port)) {
            Instance instance;
            try {
                instance = new Instance();
            } catch (IOException ex) {
                System.err.println("startOnPort: debug: " + ex.getMessage());
                return;
            }

            try {
                if (file_path != null) {
                    File logs = new File(file_path);
                    if (!logs.canWrite()) {
                        logs.createNewFile();
                        instance.setOutputStream(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(logs))), true);
                    } else {
                        System.err.println("Cannot write to file, defaulting to stdout");
                    }
                }
            } catch (NullPointerException | IOException | SecurityException ex) {
                System.err.println("Error accessing given file: reason: " + ex.getMessage());
            }

            //start instance without scanning, with a verbosity level of 1.
            instance.setParameters(port, false, 1);
            portTable.put(port, instance);
            System.out.println("Starting Service on Port " + port + "...");
            activeServices.submit(instance);
        } else {
            System.out.println("Port already being monitored!");
        }
    }

    /**
     * Returns an instance for a specific port, returns null if the port is not
     * active
     *
     * @param port
     * @return
     */
    public Instance getInstance(int port) {
        if (portTable.containsKey(port)) {
            return portTable.get(port);
        }
        return null;
    }

    /**
     * Update all running instances
     */
    
    // TODO: update name to updateState
    public void updateSettings() {
        
        // TODO: filter out each instance that is no longer valid
        portTable.forEach((i, instance) -> {
            if (instance.isRunning()) {
                instance.setVerbosity(((verbose.get()) ? 1 : 0) + ((xverbose.get()) ? 1 : 0));
                instance.runMalwareScanning(scanCymru.get());
            }
        });
    }

    public void getPortStatus() {
        StringBuilder build = new StringBuilder();
        portTable.forEach((i, instance) -> {
            if (instance.isRunning()) {
                build.append(instance.getStatus()).append('\n');
            }
        });
        System.out.println(build.toString());
    }

    /**
     * Stop instance listening on the specified port
     *
     * @param port
     */
    public void stop(int port) {
        if (alive.get()) {
            if (portTable.containsKey(port)) {
                if (portTable.get(port).isRunning()) {
                    portTable.get(port).interrupt();
                    System.out.println("Stopped Service on Port: " + port + "..."); //need to add underlying error checking for use of the sockets
                }
                portTable.remove(port);
            } else {
                System.out.println("No Service Running on Port: " + port);
            }
        }
    }

    /**
     * Attempts to shutdown all instances listening on all ports
     */
    public void shutdown() {
        portTable.values().forEach((thread) -> {
            if (thread.isRunning()) {
                thread.interrupt();
            }
        });
        this.alive.set(false);
    }

    /**
     * Returns the status of the proxy server
     *
     * @return
     */
    public boolean running() {
        return alive.get();
    }

}
