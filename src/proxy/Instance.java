package proxy;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Represents a single instance of the proxy listening on the port
 *
 * @author Torie Jenkins
 */
public class Instance extends Thread {

    //todo: create a separate output stream for each instance, add a flag for a filename 
    //in the instance manager
    //set all categories to false
    private final AtomicBoolean teamcymru = new AtomicBoolean(false);
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final AtomicBoolean verbose = new AtomicBoolean(false);
    private final AtomicBoolean xverbose = new AtomicBoolean(false);
    private final AtomicInteger port = new AtomicInteger(2020);

    //primary class resources
    private final ServerSocket listener;
    private final ThreadPoolExecutor activeConnections;

    //resource locks for the serversocket and the threadpoolexecuttor
    private final Lock conlock = new ReentrantLock();
    private final Lock soclock = new ReentrantLock();

    /**
     * Creates a standard Instance object **note: Java semantics force this
     * signature. This brings the error handling for creation outside of the
     * class.
     *
     * @throws IOException
     */
    public Instance() throws IOException {
        System.out.println("Creating socket on network interface...");
        listener = new ServerSocket();
        System.out.println("Creating threading resources...");
        activeConnections = (ThreadPoolExecutor) Executors.newCachedThreadPool();
    }

    /**
     * Starts a service through this instance object
     */
    @Override
    public void run() {
        System.out.println("Binding to port : " + port.get() + ".....");
        try {
            SocketAddress addr = new InetSocketAddress("0.0.0.0", port.get());
            soclock.lock();
            try {
                listener.bind(addr);
                listener.setSoTimeout(10000);
            } finally {
                soclock.unlock();
            }
            //if bound, continue.
            running.set(true);
        } catch (IOException ex) {
            System.err.println("Error binding socket to port " + port.get() + ": reason: " + ex.getMessage());
        }

        System.out.println("Waiting for clients :).....");
        while (running.get()) { // some try/finally madness
            try {
                Socket client;
                soclock.lock();
                conlock.lock();
                try {
                    client = listener.accept();
                    activeConnections.execute(new Process(client, verbose.get(), xverbose.get(), teamcymru.get()));
                } catch (InterruptedIOException ex) {
                    if (!running.get()) {
                        listener.close();
                        return;
                    } else {
                        continue;
                    }
                } finally {
                    soclock.unlock();
                    conlock.unlock();
                }
            } catch (IOException ex) {
                System.err.println("Err: client: dropping client: msg: " + ex.getMessage());
            }
        }
    }

    /**
     * Interrupt the current service and shutdown all active connections
     */
    @Override
    public void interrupt() {
        System.out.println("@Halting Instance @" + this.toString());
        running.set(false);
        conlock.lock();
        activeConnections.shutdownNow();
        conlock.unlock();
        super.interrupt();
    }

    /**
     * Parameter related functions: experimental with synchronized keyword
     */
    /**
     * Sets the parameters for the port ( config items )
     *
     * @param port
     * @param teamcymru
     * @param verbosity
     */
    public synchronized void setParameters(int port, boolean teamcymru, int verbosity) {
        this.port.set(port);
        this.teamcymru.set(teamcymru);
        setVerbosity(verbosity);
    }

    /**
     * Toggle Malware scanning
     *
     * @param b boolean toggle
     */
    public synchronized void runMalwareScanning(boolean b) {
        this.teamcymru.set(b);
    }

    /**
     * set's up the port to listen to
     *
     * @param p
     */
    public synchronized void setPort(int p) {
        this.port.set(p);
    }

    /**
     * Set verbosity level of instance
     *
     * @param v
     */
    public synchronized void setVerbosity(int v) {
        switch (v) {
            case 0:
                verbose.set(false);
                xverbose.set(false);
                break;
            case 1:
                verbose.set(true);
                xverbose.set(false);
                break;
            case 2:
                verbose.set(true);
                xverbose.set(true);
                break;
            default:
                break;
        }
    }
}
